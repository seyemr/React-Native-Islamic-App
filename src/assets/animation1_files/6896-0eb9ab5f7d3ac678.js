"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6896],{75296:function(e,t,n){n.d(t,{I:function(){return d},r:function(){return f}});var r=n(52983),a={fullscreenEnabled:0,fullscreenElement:1,requestFullscreen:2,exitFullscreen:3,fullscreenchange:4,fullscreenerror:5,fullscreen:6},o=["webkitFullscreenEnabled","webkitFullscreenElement","webkitRequestFullscreen","webkitExitFullscreen","webkitfullscreenchange","webkitfullscreenerror","-webkit-full-screen"],s=["mozFullScreenEnabled","mozFullScreenElement","mozRequestFullScreen","mozCancelFullScreen","mozfullscreenchange","mozfullscreenerror","-moz-full-screen"],i=["msFullscreenEnabled","msFullscreenElement","msRequestFullscreen","msExitFullscreen","MSFullscreenChange","MSFullscreenError","-ms-fullscreen"],c="undefined"!=typeof window&&void 0!==window.document?window.document:{},l="fullscreenEnabled"in c&&Object.keys(a)||o[0]in c&&o||s[0]in c&&s||i[0]in c&&i||[],u={requestFullscreen:function(e){return e[l[a.requestFullscreen]]()},requestFullscreenFunction:function(e){return e[l[a.requestFullscreen]]},get exitFullscreen(){return c[l[a.exitFullscreen]].bind(c)},get fullscreenPseudoClass(){return":"+l[a.fullscreen]},addEventListener:function(e,t,n){return c.addEventListener(l[a[e]],t,n)},removeEventListener:function(e,t,n){return c.removeEventListener(l[a[e]],t,n)},get fullscreenEnabled(){return Boolean(c[l[a.fullscreenEnabled]])},set fullscreenEnabled(e){},get fullscreenElement(){return c[l[a.fullscreenElement]]},set fullscreenElement(e){},get onfullscreenchange(){return c[("on"+l[a.fullscreenchange]).toLowerCase()]},set onfullscreenchange(e){return c[("on"+l[a.fullscreenchange]).toLowerCase()]=e},get onfullscreenerror(){return c[("on"+l[a.fullscreenerror]).toLowerCase()]},set onfullscreenerror(e){return c[("on"+l[a.fullscreenerror]).toLowerCase()]=e}};function f(){var e=(0,r.useState)(!1),t=e[0],n=e[1],a=(0,r.useRef)(null);(0,r.useEffect)((function(){var e=function(){n(u.fullscreenElement===a.current)};return u.addEventListener("fullscreenchange",e),function(){return u.removeEventListener("fullscreenchange",e)}}),[]);var o=(0,r.useCallback)((function(){return u.fullscreenElement?u.exitFullscreen().then((function(){return u.requestFullscreen(a.current)})):a.current?u.requestFullscreen(a.current):void 0}),[]),s=(0,r.useCallback)((function(){return u.fullscreenElement===a.current?u.exitFullscreen():Promise.resolve()}),[]);return(0,r.useMemo)((function(){return{active:t,enter:o,exit:s,node:a}}),[t,o,s])}var d=function(e){var t=e.handle,n=e.onChange,a=e.children,o=e.className,s=[];return o&&s.push(o),s.push("fullscreen"),t.active&&s.push("fullscreen-enabled"),(0,r.useEffect)((function(){n&&n(t.active,t)}),[t.active]),r.createElement("div",{className:s.join(" "),ref:t.node,style:t.active?{height:"100%",width:"100%"}:void 0},a)}},18885:function(e,t,n){n.d(t,{y:function(){return r}});const r={"lottie-web":{files:["build/player/lottie.min.js"],packageName:"lottie-web",versions:["5.12.2","5.12.1","5.12.0","5.11.0","5.10.2","5.10.1","5.10.0","5.9.6","5.9.5","5.9.4","5.9.3","5.9.2","5.9.1","5.9.0","5.8.1","5.8.0","5.7.14","5.7.13","5.7.12","5.7.11","5.7.10","5.7.9","5.7.8","5.7.7","5.7.6","5.7.5","5.7.4","5.7.3","5.7.2","5.7.1","5.7.0","5.6.10","5.6.8","5.6.7","5.6.6","5.6.5","5.6.4","5.6.3","5.6.2","5.6.0","5.5.10","5.5.9","5.5.8","5.5.7","5.5.6","5.5.5","5.5.4","5.5.3","5.5.2","5.5.1","5.5.0","5.4.4","5.4.3","5.4.2","5.4.1","5.4.0","5.3.4","5.3.3","5.3.2","5.3.1","5.2.1","5.2.0","5.1.20","5.1.18","5.1.17","5.1.16","5.1.15","5.1.14","5.1.13","5.1.12","5.1.11","5.1.10","5.1.9","5.1.8","5.1.7","5.1.6","5.1.5","5.1.4","5.1.3","5.1.2","5.1.1","5.1.0","5.0.6","5.0.5","5.0.4","5.0.3","5.0.2","5.0.1"]},rlottie:{files:["rlottie-wasm.js","rlottie-wasm.wasm"],packageName:"rlottie",versions:["latest"]},skottie:{files:["bin/full/canvaskit.js","bin/full/canvaskit.wasm"],packageName:"canvaskit-wasm",versions:["0.39.1","0.39.0","0.38.2","0.38.1","0.38.0","0.37.2","0.37.1","0.37.0","0.36.1","0.36.0","0.35.0","0.34.1","0.34.0","0.33.0","0.32.0","0.31.0","0.30.0","0.29.0","0.28.1","0.28.0","0.27.0","0.26.0","0.25.1","0.25.0"]},thorvg:{files:["thorvg-wasm.js","thorvg-wasm.wasm"],packageName:"thorvg",versions:["latest"]}}},9627:function(e,t,n){n.d(t,{n:function(){return H}});var r=n(18885);const a={LOTTIE_WEB:"lottie-web",RLOTTIE:"rlottie",SKOTTIE:"skottie",THORVG:"thorvg"};function o(e,t,n){var r,a;const o=null!=(a=null==(r=null==e?void 0:e[t])?void 0:r.versions)?a:[];if(0===o.length)throw new Error(`Renderer package ${t} is invalid`);return"latest"===n?o.slice(0,1):o.filter((e=>new RegExp(`^${n}$`,"u").test(e)))}function s(e,t,n){const r=o(e,t,n);if(0===r.length||void 0===r[0])throw new Error(`Version ${n} invalid for renderer ${t}`);return r[0]}const i={autoPlay:!0,bgColor:"",releaseUrl:"",direction:1,initialFrame:0,loop:!0,renderer:"lottie-web",rendererOptions:{},speed:1,timeout:6e4,version:"latest"};function c(e={}){if("object"!=typeof e)throw new Error("Config must be an object");const{animationSrc:t,autoPlay:n=i.autoPlay,bgColor:o=i.bgColor,container:c,releaseUrl:l=i.releaseUrl,direction:u=i.direction,initialFrame:f=i.initialFrame,loop:d=i.loop,renderer:p=i.renderer,rendererOptions:m=i.rendererOptions,speed:h=i.speed,timeout:g=i.timeout,version:v=i.version}=e;if(void 0===t||"string"!=typeof t&&!(t instanceof URL)&&"object"!=typeof t)throw new Error("Invalid animationSrc value");if(!(c&&c instanceof HTMLDivElement))throw new Error("Container must be a div element");if("boolean"!=typeof n||"string"!=typeof o||![-1,1].includes(u)||"number"!=typeof f||f<0||"boolean"!=typeof d||"object"!=typeof m||"number"!=typeof h||h<=0||"number"!=typeof g||g<=0||"string"!=typeof v)throw new Error("Invalid config value");if(!Object.values(a).includes(p))throw new Error("Invalid renderer");const y=s(r.y,p,v);if("string"!=typeof l||""!==l&&!1===/^(https?:\/\/|data:application\/javascript)/u.test(l))throw new Error(`Player URL must be a 'https' URL or a data URL: ${l}`);return{animationSrc:t,autoPlay:n,bgColor:o,container:c,releaseUrl:l,direction:u,initialFrame:f,loop:d,renderer:p,rendererOptions:m,speed:h,timeout:g,version:y}}const l={"lottie-web":function(){return"\n    const STATUS = { PLAYING: Symbol('playing'), PAUSED: Symbol('paused'), STOPPED: Symbol('stopped') };\n    let { currentFrame, currentState, lottieWeb, port1 } = { currentFrame: 0, currentState: STATUS.STOPPED };\n    \n    const init = async () => {\n      const container = document.querySelector('#container');\n      const rendererType = (CONFIG.rendererOptions && CONFIG.rendererOptions.rendererType) || 'svg';\n      const config = { container, rendererSettings: { preserveAspectRatio: 'xMidYMid meet', clearCanvas: rendererType === 'canvas' } };\n      return new Promise((resolve, reject) => {\n        lottieWeb = lottie.loadAnimation({ ...CONFIG, renderer: rendererType, ...config });\n        lottieWeb.setDirection(CONFIG.direction);\n        lottieWeb.setSpeed(CONFIG.speed);\n        lottieWeb.goToAndStop(currentFrame = CONFIG.initialFrame, true);\n        ['DOMLoaded', 'data_ready'].forEach(e => lottieWeb.addEventListener(e, resolve));\n        lottieWeb.addEventListener('data_failed', reject);\n        lottieWeb.addEventListener('enterFrame', () => port1.postMessage({ type: 'FRAME', frame: Number(lottieWeb.currentFrame.toFixed(0)) }));\n        lottieWeb.addEventListener('complete', () => port1.postMessage({ type: 'COMPLETE' }));\n        window.addEventListener('beforeunload', () => lottieWeb && lottieWeb.destroy());\n        setTimeout(resolve, CONFIG.timeout || 0);\n      });\n    }\n    \n    const screenshot = async () => {\n      if (!lottieWeb) {\n        throw new Error('Lottie-web not loaded');\n      }\n      const canvas = new OffscreenCanvas(container.offsetWidth, container.offsetHeight);\n      const canvasContext = canvas.getContext('2d');\n      if (lottieWeb.animType === 'svg') {\n        await new Promise((resolve, reject) => {\n          const image = new Image();\n          image.onload = async () => {\n            if (CONFIG.bgColor) {\n              canvasContext.rect(0, 0, canvas.width, canvas.height);\n              canvasContext.fillStyle = CONFIG.bgColor;\n              canvasContext.fill();\n            }\n            canvasContext.drawImage(image, 0, 0, canvas.width, canvas.height);\n            URL.revokeObjectURL(image.src);\n            resolve();\n          };\n          image.onerror = reject;\n          image.src = URL.createObjectURL(new Blob([lottieWeb.wrapper.firstChild.outerHTML], { type: 'image/svg+xml' }));\n        });\n      } else if (lottieWeb.animType === 'canvas') {\n        const bitmap = await createImageBitmap(container.firstChild);\n        if (CONFIG.bgColor) {\n          canvasContext.fillStyle = CONFIG.bgColor;\n          canvasContext.fillRect(0, 0, canvas.width, canvas.height);\n        }\n        canvasContext.drawImage(bitmap, 0, 0, canvas.width, canvas.height);\n      } else {\n        throw new Error('Unsupported renderer type');\n      }\n      return canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n    }\n    \n    const messageHandler = async ({ data: { type, ...data } }) => {\n      if (!type || !lottieWeb) {\n        return;\n      }\n      try {\n        if (type === 'DESTROY') {\n          lottieWeb.destroy();\n        } else if (type === 'PAUSE') {\n          lottieWeb.pause();\n          currentState = STATUS.PAUSED;\n        } else if (type === 'PLAY') {\n          lottieWeb.play();\n          currentState = STATUS.PLAYING;\n        } else if (type === 'SCREENSHOT') {\n          const image = await screenshot();\n          port1.postMessage({ type: 'SCREENSHOT', image }, [image.data.buffer]);\n        } else if (type === 'SEEK') {\n          if (typeof data.frame !== 'number') {\n            throw new TypeError('Frame must be a number');\n          }\n          currentState === STATUS.PLAYING ? lottieWeb.goToAndPlay(data.frame, true) : lottieWeb.goToAndStop(data.frame, true), lottieWeb.pause();\n          port1.postMessage({ type: 'FRAME', frame: data.frame });\n        } else if (type === 'SET_BG_COLOR') {\n          CONFIG.bgColor = data.bgColor ?? '';\n        } else if (type === 'SET_DIRECTION') {\n          if (data.direction !== -1 && data.direction !== 1) {\n            throw new TypeError('Direction must be -1 or 1');\n          }\n          lottieWeb.setDirection(data.direction);\n        } else if (type === 'SET_LOOPING') {\n          if (typeof data.loop !== 'boolean') {\n            throw new TypeError('Loop must be a boolean');\n          }\n          lottieWeb.loop = data.loop;\n        } else if (type === 'SET_SPEED') {\n          if (typeof data.speed !== 'number') {\n            throw new TypeError('Speed must be a number');\n          }\n          lottieWeb.setSpeed(data.speed);\n        } else if (type === 'STOP') {\n          lottieWeb.stop();\n          currentState = STATUS.STOPPED;\n        } else if (type === 'SVG') {\n          port1.postMessage({ type: 'SVG', svg: lottieWeb.wrapper.firstChild.outerHTML });\n        }\n      } catch (err) {\n        port1.postMessage({ type: 'ERROR', message: err.message });\n      }\n    }\n    \n    window.addEventListener('message', async ({ data: { port1: p1 } }) => {\n      port1 = p1;\n      port1.onmessage = messageHandler;\n      try {\n        await init();\n        port1.postMessage({ type: 'INITIALIZED', totalFrames: lottieWeb.totalFrames });\n        port1.postMessage({ type: 'FRAME', frame: currentFrame });\n      } catch (err) {\n        port1.postMessage({ type: 'ERROR', message: err.message });\n      }\n    }, { once: true });\n  "},rlottie:function(){return"const STATUS = { PLAYING: Symbol('playing'), PAUSED: Symbol('paused'), STOPPED: Symbol('stopped') };\n  let { rlottie, dimensions, currentFrame, currentState, frameRate, duration, progress, startTime, totalFrames, firstFrame } = { currentFrame: 0, currentState: STATUS.STOPPED };\n  const container = document.querySelector('#container');\n  const canvas = container.appendChild(document.createElement('canvas'));\n  const canvasContext = canvas.getContext('2d');\n  \n  async function init() {\n    rlottie = new Module.RlottieWasm();\n    rlottie.load(JSON.stringify(CONFIG.animationData));\n    firstFrame = CONFIG.animationData['ip'];\n    totalFrames = rlottie.frames() - 1;\n    frameRate = CONFIG.animationData['fr'];\n    duration = (totalFrames / frameRate) * 1000;\n    dimensions = [CONFIG.animationData['w'], CONFIG.animationData['h']];\n    CONFIG.bgColor = CONFIG.bgColor || '';\n    currentFrame = CONFIG.initialFrame || 0;\n    progress = currentFrame / totalFrames;\n    resizeCanvas(document.body.offsetWidth, document.body.offsetHeight);\n    renderFrame();\n  }\n  \n  function resizeCanvas(width, height) {\n    [canvas.width, canvas.height] = resize([CONFIG.animationData['w'], CONFIG.animationData['h']], [width, height]);\n  }\n  \n  function resize(source, target) {\n    if (!source[0] || !source[1]) {\n      throw new Error('Both source width and height must be provided.');\n    }\n    const sourceRatio = source[0] / source[1];\n    let output = [...source];\n    if (target[0] && !target[1]) {\n      output = [target[0], target[0] / sourceRatio];\n    } else if (!target[0] && target[1]) {\n      output = [target[1] * sourceRatio, target[1]];\n    } else if (target[0] && target[1]) {\n      output = sourceRatio > target[0] / target[1] ? [target[0], target[0] / sourceRatio] : [target[1] * sourceRatio, target[1]];\n    }\n    return output.map(Math.round);\n  }\n  \n  async function renderFrame() {\n    if (!rlottie) {\n      return;\n    }\n    if (currentState === STATUS.PLAYING) {\n      progress = ((((new Date().getTime() - firstFrame) * CONFIG.speed) / duration) % 1.0) * (CONFIG.direction === -1 ? -1 : 1);\n    }\n    currentFrame = Number((progress * totalFrames).toFixed(0));\n    const buffer = rlottie.render(currentFrame, canvas.width, canvas.height);\n    const imageData = new ImageData(Uint8ClampedArray.from(buffer), canvas.width, canvas.height);\n    const bitmap = await createImageBitmap(imageData);\n\n    canvasContext.save();\n    if (CONFIG.bgColor) {\n      canvasContext.fillStyle = CONFIG.bgColor;\n      canvasContext.fillRect(0, 0, canvas.width, canvas.height);\n    } else {\n      canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n    }\n    canvasContext.restore();\n\n    canvasContext.drawImage(bitmap, 0, 0, canvas.width, canvas.height);\n    port1.postMessage({ type: 'FRAME', frame: Number(currentFrame.toFixed(0)) });\n    if (CONFIG.loop === false && currentFrame === totalFrames) {\n      return;\n    }\n    if (currentState === STATUS.PLAYING) {\n      window.requestAnimationFrame(renderFrame);\n    }\n  }\n  \n  function screenshot() {\n    if (!rlottie) {\n      throw new Error('Player not initialized');\n    }\n    return canvasContext.getImageData(0, 0, canvas.width, canvas.height).data;\n  }\n  \n  async function messageHandler({ data: { type, ...data } }) {\n    if (!type) {\n      return;\n    }\n    try {\n      if (type === 'DESTROY') {\n        rlottie.destroy();\n      } else if (type === 'PAUSE') {\n        currentState = STATUS.PAUSED;\n      } else if (type === 'PLAY') {\n        if (currentState !== STATUS.PLAYING) {\n          startTime = new Date().getTime() - (currentState === STATUS.PAUSED ? progress * duration : 0);\n          currentState = STATUS.PLAYING;\n          renderFrame();\n        }\n      } else if (type === 'SCREENSHOT') {\n        const imageData = screenshot();\n        port1.postMessage({ type: 'SCREENSHOT', data: imageData }, [imageData.buffer]);\n      } else if (type === 'SEEK') {\n        if (typeof data.frame !== 'number') {\n          throw new TypeError('Frame must be a number');\n        }\n        currentFrame = data.frame;\n        progress = currentFrame / totalFrames;\n        renderFrame();\n      } else if (type === 'SET_BG_COLOR') {\n        CONFIG.bgColor = data.bgColor || '';\n      } else if (type === 'SET_DIRECTION') {\n        if (data.direction !== -1 && data.direction !== 1) {\n          throw new TypeError('Direction must be -1 or 1');\n        }\n        CONFIG.direction = data.direction;\n      } else if (type === 'SET_LOOPING') {\n        if (typeof data.loop !== 'boolean') {\n          throw new TypeError('Loop must be a boolean');\n        }\n        CONFIG.loop = data.loop;\n      } else if (type === 'SET_SPEED') {\n        if (typeof data.speed !== 'number') {\n          throw new TypeError('Speed must be a number');\n        }\n        CONFIG.speed = data.speed;\n      } else if (type === 'STOP') {\n        progress = 0;\n        currentState = STATUS.STOPPED;\n        renderFrame();\n      }\n    } catch (err) {\n      port1.postMessage({ type: 'ERROR', message: err.message }, '*');\n    }\n  }\n  \n  window.addEventListener('message', async ({ data }) => {\n    port1 = data.port1;\n    port1.onmessage = messageHandler;\n    Module.onRuntimeInitialized = async () => {\n      await init();\n      port1.postMessage({ type: 'INITIALIZED', totalFrames });\n    }\n  }, { once: true });\n  \n  new ResizeObserver(entries => {\n    if (!rlottie) {\n      return;\n    }\n    for (const entry of entries) {\n      resizeCanvas(entry.contentRect.width, entry.contentRect.height);\n    }\n  }).observe(document.body);\n  "},skottie:function(){return"const STATUS = { PLAYING: Symbol('playing'), PAUSED: Symbol('paused'), STOPPED: Symbol('stopped') };\n  const container = document.querySelector('#container');\n  const canvas = container.appendChild(document.createElement('canvas'));\n  let bounds = null;\n  let skCanvas = null;\n  let canvasKit = null;\n  let currentFrame = 0;\n  let currentState = STATUS.STOPPED;\n  let dimensions = null;\n  let duration = 0;\n  let startTime = 0;\n  let progress = 0;\n  let skottie = null;\n  let surface = null;\n  let totalFrames = 0;\n  \n  async function init() {\n    canvasKit = await CanvasKitInit();\n    skottie = canvasKit.MakeManagedAnimation(JSON.stringify(CONFIG.animationData));\n    duration = skottie.duration() * 1000;\n    totalFrames = Math.round(skottie.fps() * skottie.duration());\n    dimensions = skottie.size();\n    CONFIG.bgColor = CONFIG.bgColor ? canvasKit.parseColorString(CONFIG.bgColor) : canvasKit.TRANSPARENT;\n    currentFrame = CONFIG.initialFrame || 0;\n    progress = currentFrame / totalFrames;\n    createSurface(document.body.offsetWidth, document.body.offsetHeight);\n    renderFrame();\n  }\n  \n  function createSurface(width, height) {\n    [canvas.width, canvas.height] = resize(dimensions, [width, height]);\n    try {\n      surface = canvasKit.MakeWebGLCanvasSurface(canvas, canvasKit.ColorSpace.SRGB, { antialias: 1 });\n    } catch (err) {\n      surface = canvasKit.MakeSWCanvasSurface(canvas);\n    }\n    skCanvas = surface.getCanvas();\n    bounds = Float32Array.from([0, 0, canvas.width, canvas.height]);\n  }\n  \n  function resize(source, target) {\n    if (!source[0] || !source[1]) {\n      throw new Error('Both source width and height must be provided.');\n    }\n    const sourceRatio = source[0] / source[1];\n    let output = [...source];\n    if (target[0] && !target[1]) {\n      output = [target[0], target[0] / sourceRatio];\n    } else if (!target[0] && target[1]) {\n      output = [target[1] * sourceRatio, target[1]];\n    } else if (target[0] && target[1]) {\n      output = sourceRatio > target[0] / target[1] ? [target[0], target[0] / sourceRatio] : [target[1] * sourceRatio, target[1]];\n    }\n    return output.map(Math.round);\n  }\n  \n  function screenshot() {\n    const pixelData = skCanvas.readPixels(0, 0, {\n      alphaType: canvasKit.AlphaType.Premul,\n      colorSpace: canvasKit.ColorSpace.SRGB,\n      colorType: canvasKit.ColorType.RGBA_8888,\n      width: skCanvas.width,\n      height: skCanvas.height,\n    });\n    return new ImageData(new Uint8ClampedArray(pixelData), skCanvas.width, skCanvas.height);\n  }\n  \n  async function messageHandler({ data: { type, ...data } }) {\n    if (!type || !skottie || !canvasKit || !skCanvas || !surface) {\n      return;\n    }\n    try {\n      if (type === 'DESTROY') {\n        skottie.delete();\n      } else if (type === 'PAUSE') {\n        currentState = STATUS.PAUSED;\n      } else if (type === 'PLAY') {\n        if (currentState !== STATUS.PLAYING) {\n          startTime = new Date().getTime() - (currentState === STATUS.PAUSED ? progress * duration : 0);\n          currentState = STATUS.PLAYING;\n          renderFrame();\n        }\n      } else if (type === 'SCREENSHOT') {\n        const imageData = screenshot();\n        port1.postMessage({ type: 'SCREENSHOT', data: imageData }, [imageData.data.buffer]);\n      } else if (type === 'SEEK') {\n        if (typeof data.frame !== 'number') throw new TypeError('Frame must be a number');\n        progress = data.frame / totalFrames;\n        renderFrame();\n      } else if (type === 'SET_BG_COLOR') {\n        CONFIG.bgColor = data.bgColor ? canvasKit.parseColorString(data.bgColor) : canvasKit.TRANSPARENT;\n      } else if (type === 'SET_DIRECTION') {\n        if (data.direction !== -1 && data.direction !== 1) {\n          throw new TypeError('Direction must be -1 or 1');\n        }\n        CONFIG.direction = data.direction;\n      } else if (type === 'SET_LOOPING') {\n        if (typeof data.loop !== 'boolean') {\n          throw new TypeError('Loop must be a boolean');\n        } else {\n          CONFIG.loop = data.loop;\n        }\n      } else if (type === 'SET_SPEED') {\n        if (typeof data.speed !== 'number') {\n          throw new TypeError('Speed must be a number'); \n        } else {\n          CONFIG.speed = data.speed;\n        }\n      } else if (type === 'STOP') {\n        progress = 0;\n        currentState = STATUS.STOPPED;\n        renderFrame();\n      }\n    } catch (err) {\n      port1.postMessage({ type: 'ERROR', message: err.message }, '*');\n    }\n  }\n  \n  function renderFrame() {\n    if (currentState === STATUS.PLAYING) {\n      progress = ((((new Date().getTime() - startTime) * CONFIG.speed) / duration) % 1.0) * (CONFIG.direction === -1 ? -1 : 1);\n    }\n    currentFrame = Number((progress * totalFrames).toFixed(0));\n    skottie.seek(progress);\n    skCanvas.clear(CONFIG.bgColor);\n    skottie.render(skCanvas, bounds);\n    surface.flush();\n    port1.postMessage({ type: 'FRAME', frame: currentFrame });\n    if (CONFIG.loop === false && currentFrame === totalFrames) {\n      return;\n    }\n    if (currentState === STATUS.PLAYING) {\n      surface.requestAnimationFrame(renderFrame);\n    }\n  }\n  \n  window.addEventListener('message', async ({ data }) => {\n    port1 = data.port1;\n    port1.onmessage = messageHandler;\n    await init();\n    \n    port1.postMessage({ type: 'INITIALIZED', totalFrames });\n  }, { once: true });\n  \n  new ResizeObserver(entries => {\n    if (!surface) {\n      return;\n    }\n    for (const entry of entries) {\n      createSurface(entry.contentRect.width, entry.contentRect.height);\n    }\n  }).observe(document.body);"},thorvg:function(){return"const STATUS = { PLAYING: Symbol('playing'), PAUSED: Symbol('paused'), STOPPED: Symbol('stopped') };\n  let { tvg, dimensions, currentFrame, currentState, frameRate, duration, progress, startTime, totalFrames, firstFrame } = { currentFrame: 0, currentState: STATUS.STOPPED };\n  const container = document.querySelector('#container');\n  const canvas = container.appendChild(document.createElement('canvas'));\n  const canvasContext = canvas.getContext('2d');\n  \n  async function init() {\n    dimensions = [CONFIG.animationData['w'], CONFIG.animationData['h']];\n    tvg = new Module.TvgWasm();\n    tvg.load(JSON.stringify(CONFIG.animationData), 'lottie', dimensions[0], dimensions[1]);\n    firstFrame = CONFIG.animationData['ip'];\n    totalFrames = Math.round(tvg.totalFrame());\n    frameRate = CONFIG.animationData['fr'];\n    duration = (totalFrames / frameRate) * 1000;\n    CONFIG.bgColor = CONFIG.bgColor || '';\n    currentFrame = CONFIG.initialFrame || 0;\n    progress = currentFrame / totalFrames;\n    resizeCanvas(document.body.offsetWidth, document.body.offsetHeight);\n    renderFrame();\n  }\n  \n  function resizeCanvas(width, height) {\n    [canvas.width, canvas.height] = resize([CONFIG.animationData['w'], CONFIG.animationData['h']], [width, height]);\n  }\n  \n  function resize(source, target) {\n    if (!source[0] || !source[1]) {\n      throw new Error('Both source width and height must be provided.');\n    }\n    const sourceRatio = source[0] / source[1];\n    let output = [...source];\n    if (target[0] && !target[1]) {\n      output = [target[0], target[0] / sourceRatio];\n    } else if (!target[0] && target[1]) {\n      output = [target[1] * sourceRatio, target[1]];\n    } else if (target[0] && target[1]) {\n      output = sourceRatio > target[0] / target[1] ? [target[0], target[0] / sourceRatio] : [target[1] * sourceRatio, target[1]];\n    }\n    return output.map(Math.round);\n  }\n  \n  async function renderFrame() {\n    if (!tvg) return;\n    if (currentState === STATUS.PLAYING) {\n      progress = ((((new Date().getTime() - firstFrame) * CONFIG.speed) / duration) % 1.0) * (CONFIG.direction === -1 ? -1 : 1);\n    }\n    currentFrame = Number((progress * totalFrames).toFixed(0));\n\n    tvg.frame(currentFrame);\n    tvg.resize(canvas.width, canvas.height);\n    if (tvg.update() === true) {\n      const buffer = tvg.render();\n      const clampedBuffer = Uint8ClampedArray.from(buffer);\n      if (clampedBuffer.length === 0) return;\n      const imageData = new ImageData(clampedBuffer, canvas.width, canvas.height);\n      const bitmap = await createImageBitmap(imageData);\n      \n      canvasContext.save();\n      if (CONFIG.bgColor) {\n        canvasContext.fillStyle = CONFIG.bgColor;\n        canvasContext.fillRect(0, 0, canvas.width, canvas.height);\n      } else {\n        canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n      }\n      canvasContext.restore();\n\n      canvasContext.drawImage(bitmap, 0, 0, canvas.width, canvas.height);\n      port1.postMessage({ type: 'FRAME', frame: Number(currentFrame.toFixed(0)) });\n    }\n    if (CONFIG.loop === false && currentFrame === totalFrames) return;\n    if (currentState === STATUS.PLAYING) {\n      window.requestAnimationFrame(renderFrame);\n    }\n  }\n  \n  function screenshot() {\n    if (!tvg) throw new Error('Player not initialized');\n    return canvasContext.getImageData(0, 0, canvas.width, canvas.height).data;\n  }\n  \n  async function messageHandler({ data: { type, ...data } }) {\n    if (!type) return;\n    try {\n      if (type === 'DESTROY') {\n        tvg.destroy();\n      } else if (type === 'PAUSE') {\n        currentState = STATUS.PAUSED;\n      } else if (type === 'PLAY') {\n        if (currentState !== STATUS.PLAYING) {\n          startTime = new Date().getTime() - (currentState === STATUS.PAUSED ? progress * duration : 0);\n          currentState = STATUS.PLAYING;\n          renderFrame();\n        }\n      } else if (type === 'SCREENSHOT') {\n        const imageData = screenshot();\n        port1.postMessage({ type: 'SCREENSHOT', data: imageData }, [imageData.buffer]);\n      } else if (type === 'SEEK') {\n        if (typeof data.frame !== 'number') {\n          throw new TypeError('Frame must be a number');\n        }\n        currentFrame = data.frame;\n        progress = currentFrame / totalFrames;\n        renderFrame();\n      } else if (type === 'SET_BG_COLOR') {\n        CONFIG.bgColor = data.bgColor || '';\n      } else if (type === 'SET_DIRECTION') {\n        if (data.direction !== -1 && data.direction !== 1) {\n          throw new TypeError('Direction must be -1 or 1');\n        }\n        CONFIG.direction = data.direction;\n      } else if (type === 'SET_LOOPING') {\n        if (typeof data.loop !== 'boolean') {\n          throw new TypeError('Loop must be a boolean');\n        }\n        CONFIG.loop = data.loop;\n      } else if (type === 'SET_SPEED') {\n        if (typeof data.speed !== 'number') {\n          throw new TypeError('Speed must be a number');\n        }\n        CONFIG.speed = data.speed;\n      } else if (type === 'STOP') {\n        progress = 0;\n        currentState = STATUS.STOPPED;\n        renderFrame();\n      }\n    } catch (err) {\n      port1.postMessage({ type: 'ERROR', message: err.message }, '*');\n    }\n  }\n  \n  window.addEventListener('message', async ({ data }) => {\n    port1 = data.port1;\n    port1.onmessage = messageHandler;\n    Module.onRuntimeInitialized = async () => {\n      await init();\n      port1.postMessage({ type: 'INITIALIZED', totalFrames });\n    }\n  }, { once: true });\n  \n  new ResizeObserver(entries => {\n    if (!tvg) return;\n    for (const entry of entries) resizeCanvas(entry.contentRect.width, entry.contentRect.height);\n  }).observe(document.body);\n  "}};async function u(e){let t={};if(e instanceof URL||"string"==typeof e){const n=e.toString();if(/^(https?:\/\/|data:application\/json).*/gu.test(n))try{t=await(await fetch(n)).json()}catch(e){throw new Error("Failed to load animation data from URL")}else if("string"==typeof e)try{t=JSON.parse(e)}catch(e){throw new Error("Failed to parse animation data")}}else{if("object"!=typeof e||null===e)throw new Error("Invalid animation src");t=e}if(!function(e){return"object"==typeof e&&null!==e&&!1===Array.isArray(e)&&["fr","ip","op","w","h","layers"].every((t=>t in e))}(t))throw new Error("Resolved animation data is not lottie-like");return t}var f,d,p,m,h,g,v,y,b,w,S,E,C,F,T,_,O=Object.defineProperty,I=Object.defineProperties,N=Object.getOwnPropertyDescriptors,R=Object.getOwnPropertySymbols,A=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable,P=(e,t,n)=>t in e?O(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,x=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)},D=(e,t,n)=>(x(e,t,"read from private field"),n?n.call(e):t.get(e)),L=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n)},G=(e,t,n,r)=>(x(e,t,"write to private field"),r?r.call(e,n):t.set(e,n),n),M=(e,t,n)=>(x(e,t,"access private method"),n);const z={Idle:"Idle",Paused:"Paused",Playing:"Playing",Stopped:"Stopped"},U={COMPLETE:"COMPLETE",ERROR:"ERROR",FRAME:"FRAME",INITIALIZED:"INITIALIZED",SCREENSHOT:"SCREENSHOT",SVG:"SVG"},j=class{constructor(e){L(this,b),L(this,S),L(this,C),L(this,T),L(this,f,{}),L(this,d,void 0),L(this,p,void 0),L(this,m,new Map),L(this,h,void 0),L(this,g,void 0),L(this,v,"Idle"),L(this,y,-1),G(this,h,c(null!=e?e:{})),G(this,d,D(this,h).initialFrame)}static async create(e){var t;const n=new j(e);return await M(t=n,b,w).call(t),n}get animationData(){return D(this,f)}get currentFrame(){return D(this,d)}get renderer(){return D(this,h).renderer}get state(){return D(this,v)}get totalFrames(){return D(this,y)}get version(){return D(this,h).version}addEventListener(e,t){var n;if("function"==typeof t&&Object.keys(U).includes(e)){const r=null!=(n=D(this,m).get(e))?n:[];r.push(t),D(this,m).set(e,r)}}destroy(){D(this,p)&&D(this,p).call(this),M(this,C,F).call(this)}pause(){M(this,S,E).call(this,{type:"PAUSE"}),M(this,T,_).call(this,z.Paused)}play(){M(this,S,E).call(this,{type:"PLAY"}),M(this,T,_).call(this,z.Playing)}removeEventListener(e,t){const n=D(this,m).get(e);n&&D(this,m).set(e,n.filter((e=>e!==t)))}screenshot(){M(this,S,E).call(this,{type:"SCREENSHOT"})}seek(e){if("number"!=typeof e||e<0||e>D(this,y))throw new Error(`Invalid frame: ${e}`);M(this,S,E).call(this,{frame:e,type:"SEEK"})}setBgColor(e){M(this,S,E).call(this,{bgColor:e,type:"SET_BG_COLOR"}),D(this,h).bgColor=e}setDirection(e){if("number"!=typeof e)throw new Error(`Invalid direction: ${String(e)}`);M(this,S,E).call(this,{direction:e,type:"SET_DIRECTION"}),D(this,h).direction=e>=0?1:-1}setLooping(e){M(this,S,E).call(this,{loop:e,type:"SET_LOOPING"}),D(this,h).loop=e}async setRenderer(e,t="latest"){void 0!==D(this,p)&&D(this,p).call(this),D(this,h).renderer=e,D(this,h).version=s(r.y,e,t),await M(this,b,w).call(this)}setSpeed(e){if("number"!=typeof e||e<0)throw new Error(`Invalid speed: ${e}`);M(this,S,E).call(this,{speed:e,type:"SET_SPEED"}),D(this,h).speed=e}stop(){M(this,S,E).call(this,{type:"STOP"}),M(this,T,_).call(this,z.Stopped)}svg(){M(this,S,E).call(this,{type:"SVG"})}};let W=j;f=new WeakMap,d=new WeakMap,p=new WeakMap,m=new WeakMap,h=new WeakMap,g=new WeakMap,v=new WeakMap,y=new WeakMap,b=new WeakSet,w=async function(){const e=D(this,h).releaseUrl||function(e,t,n){var r,a;const s=null==(a=null==(r=null==e?void 0:e[t])?void 0:r.files)?void 0:a.find((e=>e.endsWith(".js"))),i=o(e,t,n);if(0===i.length)throw new Error(`Version ${n} invalid for renderer ${t}`);return`https://players.assets.lottiefiles.com/${t}/${i[0]}/${s}`}(r.y,D(this,h).renderer,D(this,h).version);G(this,f,await u(D(this,h).animationSrc));const t=new MessageChannel;G(this,g,t.port2),G(this,p,await async function(e){if(!(e.renderer in l))throw new Error(`Renderer "${e.renderer}" is not supported`);const t=l[e.renderer](),n=`<html><head><meta charset="UTF-8"><script src="${e.releaseUrl}"><\/script><script>const CONFIG = ${JSON.stringify({animationData:e.animationData,autoPlay:e.autoPlay,bgColor:e.bgColor,direction:e.direction,initialFrame:e.initialFrame,loop:e.loop,rendererOptions:e.rendererOptions,speed:e.speed,timeout:e.timeout})};<\/script><style>*, *::before, *::after { box-sizing: border-box;};body { margin: 0; display: flex; justify-content: center; align-items: center; overflow: hidden; }</style></head><body><div id="container" style="width: 100%; height: 100%;"></div><script>${t}<\/script></body></html>`,r=document.createElement("iframe",{});let a,o;r.style.width="100%",r.style.height="100%",r.style.border="none",e.container.replaceChildren(r),r.src=URL.createObjectURL(new Blob([n],{type:"text/html; charset=utf-8"}));const s=new Promise(((e,t)=>{a=e,o=t}));return e.channel.port2.addEventListener("message",(({data:t})=>{if("object"==typeof t&&null!==t&&!("type"in t))return;const n=t;"INITIALIZED"===n.type&&a(),e.onMessageCallback(n)})),e.channel.port2.start(),r.addEventListener("load",(()=>{var t;null==(t=r.contentWindow)||t.postMessage({port1:e.channel.port1},"*",[e.channel.port1])})),r.addEventListener("error",(()=>o(new Error("Failed to load iframe")))),setTimeout((()=>o(new Error("Timeout"))),e.timeout),await s,()=>{e.container.replaceChildren(),URL.revokeObjectURL(r.src)}}(((e,t)=>I(e,N(t)))(((e,t)=>{for(var n in t||(t={}))A.call(t,n)&&P(e,n,t[n]);if(R)for(var n of R(t))k.call(t,n)&&P(e,n,t[n]);return e})({},D(this,h)),{animationData:D(this,f),channel:t,onMessageCallback:e=>{"FRAME"===e.type?G(this,d,e.frame):"INITIALIZED"===e.type&&G(this,y,e.totalFrames);const t=D(this,m).get(e.type);if(Array.isArray(t))for(const n of t)n(e)},releaseUrl:e}))),D(this,h).autoPlay?this.play():this.stop()},S=new WeakSet,E=function(e){D(this,g)&&D(this,g).postMessage(e)},C=new WeakSet,F=function(){G(this,f,{}),G(this,d,0),G(this,v,"Idle"),G(this,y,-1),D(this,m).clear()},T=new WeakSet,_=function(e){D(this,g)&&e in z&&G(this,v,e)};var q=n(52983);function H({animationSrc:e,autoPlay:t,bgColor:n,containerRef:r,direction:a,initialFrame:o,loop:s,renderer:i,rendererOptions:c,speed:l,version:u}){const[f,d]=q.useState(),[p,m]=q.useState(),h=q.useCallback((async()=>{if(r.current){m(""),f&&(d(void 0),f.destroy());try{const f=await W.create({animationSrc:e,autoPlay:t,bgColor:n,container:r.current,direction:a,initialFrame:o,loop:s,renderer:i,rendererOptions:c,speed:l,version:u});d(f)}catch(e){e instanceof Error?m(e.message):m("Unknown error")}}}),[e,r.current,i,c,u,d]);return q.useEffect((()=>{h()}),[e,i,u,c]),q.useEffect((()=>{f&&"string"==typeof n&&f.setBgColor(n)}),[n]),q.useEffect((()=>{f&&"number"==typeof a&&f.setDirection(a)}),[a]),q.useEffect((()=>{f&&"number"==typeof l&&f.setSpeed(l)}),[l]),q.useEffect((()=>{f&&"boolean"==typeof s&&f.setLooping(s)}),[s]),{error:p,player:f}}},79120:function(e,t,n){function r(e,t,n){return Math.min(Math.max(e,n),t)}n.d(t,{H3:function(){return v}});class a extends Error{constructor(e){super(`Failed to parse color: "${e}"`)}}var o=a;function s(e){if("string"!=typeof e)throw new o(e);if("transparent"===e.trim().toLowerCase())return[0,0,0,0];let t=e.trim();t=m.test(e)?function(e){const t=e.toLowerCase().trim(),n=c[function(e){let t=5381,n=e.length;for(;n;)t=33*t^e.charCodeAt(--n);return(t>>>0)%2341}(t)];if(!n)throw new o(e);return`#${n}`}(e):e;const n=u.exec(t);if(n){const e=Array.from(n).slice(1);return[...e.slice(0,3).map((e=>parseInt(l(e,2),16))),parseInt(l(e[3]||"f",2),16)/255]}const a=f.exec(t);if(a){const e=Array.from(a).slice(1);return[...e.slice(0,3).map((e=>parseInt(e,16))),parseInt(e[3]||"ff",16)/255]}const s=d.exec(t);if(s){const e=Array.from(s).slice(1);return[...e.slice(0,3).map((e=>parseInt(e,10))),parseFloat(e[3]||"1")]}const i=p.exec(t);if(i){const[t,n,a,s]=Array.from(i).slice(1).map(parseFloat);if(r(0,100,n)!==n)throw new o(e);if(r(0,100,a)!==a)throw new o(e);return[...g(t,n,a),s||1]}throw new o(e)}const i=e=>parseInt(e.replace(/_/g,""),36),c="1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce(((e,t)=>{const n=i(t.substring(0,3)),r=i(t.substring(3)).toString(16);let a="";for(let e=0;e<6-r.length;e++)a+="0";return e[n]=`${a}${r}`,e}),{});const l=(e,t)=>Array.from(Array(t)).map((()=>e)).join(""),u=new RegExp(`^#${l("([a-f0-9])",3)}([a-f0-9])?$`,"i"),f=new RegExp(`^#${l("([a-f0-9]{2})",3)}([a-f0-9]{2})?$`,"i"),d=new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${l(",\\s*(\\d+)\\s*",2)}(?:,\\s*([\\d.]+))?\\s*\\)$`,"i"),p=/^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i,m=/^[a-z]+$/i,h=e=>Math.round(255*e),g=(e,t,n)=>{let r=n/100;if(0===t)return[r,r,r].map(h);const a=(e%360+360)%360/60,o=(1-Math.abs(2*r-1))*(t/100),s=o*(1-Math.abs(a%2-1));let i=0,c=0,l=0;a>=0&&a<1?(i=o,c=s):a>=1&&a<2?(i=s,c=o):a>=2&&a<3?(c=o,l=s):a>=3&&a<4?(c=s,l=o):a>=4&&a<5?(i=s,l=o):a>=5&&a<6&&(i=o,l=s);const u=r-o/2;return[i+u,c+u,l+u].map(h)};function v(e){if("transparent"===e)return 0;function t(e){const t=e/255;return t<=.03928?t/12.92:Math.pow((t+.055)/1.055,2.4)}const[n,r,a]=s(e);return.2126*t(n)+.7152*t(r)+.0722*t(a)}},51031:function(e,t,n){n.d(t,{ZE:function(){return L},gW:function(){return k}});var r=n(52983);function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function o(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t.indexOf(n=o[r])>=0||(a[n]=e[n]);return a}function s(e){var t=(0,r.useRef)(e),n=(0,r.useRef)((function(e){t.current&&t.current(e)}));return t.current=e,n.current}var i=function(e,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),e>n?n:e<t?t:e},c=function(e){return"touches"in e},l=function(e){return e&&e.ownerDocument.defaultView||self},u=function(e,t,n){var r=e.getBoundingClientRect(),a=c(t)?function(e,t){for(var n=0;n<e.length;n++)if(e[n].identifier===t)return e[n];return e[0]}(t.touches,n):t;return{left:i((a.pageX-(r.left+l(e).pageXOffset))/r.width),top:i((a.pageY-(r.top+l(e).pageYOffset))/r.height)}},f=function(e){!c(e)&&e.preventDefault()},d=r.memo((function(e){var t=e.onMove,n=e.onKey,i=o(e,["onMove","onKey"]),d=(0,r.useRef)(null),p=s(t),m=s(n),h=(0,r.useRef)(null),g=(0,r.useRef)(!1),v=(0,r.useMemo)((function(){var e=function(e){f(e),(c(e)?e.touches.length>0:e.buttons>0)&&d.current?p(u(d.current,e,h.current)):n(!1)},t=function(){return n(!1)};function n(n){var r=g.current,a=l(d.current),o=n?a.addEventListener:a.removeEventListener;o(r?"touchmove":"mousemove",e),o(r?"touchend":"mouseup",t)}return[function(e){var t=e.nativeEvent,r=d.current;if(r&&(f(t),!function(e,t){return t&&!c(e)}(t,g.current)&&r)){if(c(t)){g.current=!0;var a=t.changedTouches||[];a.length&&(h.current=a[0].identifier)}r.focus(),p(u(r,t,h.current)),n(!0)}},function(e){var t=e.which||e.keyCode;t<37||t>40||(e.preventDefault(),m({left:39===t?.05:37===t?-.05:0,top:40===t?.05:38===t?-.05:0}))},n]}),[m,p]),y=v[0],b=v[1],w=v[2];return(0,r.useEffect)((function(){return w}),[w]),r.createElement("div",a({},i,{onTouchStart:y,onMouseDown:y,className:"react-colorful__interactive",ref:d,onKeyDown:b,tabIndex:0,role:"slider"}))})),p=function(e){return e.filter(Boolean).join(" ")},m=function(e){var t=e.color,n=e.left,a=e.top,o=void 0===a?.5:a,s=p(["react-colorful__pointer",e.className]);return r.createElement("div",{className:s,style:{top:100*o+"%",left:100*n+"%"}},r.createElement("div",{className:"react-colorful__pointer-fill",style:{backgroundColor:t}}))},h=function(e,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*e)/n},g=(Math.PI,function(e){return"#"===e[0]&&(e=e.substr(1)),e.length<6?{r:parseInt(e[0]+e[0],16),g:parseInt(e[1]+e[1],16),b:parseInt(e[2]+e[2],16),a:1}:{r:parseInt(e.substr(0,2),16),g:parseInt(e.substr(2,2),16),b:parseInt(e.substr(4,2),16),a:1}}),v=function(e){var t=e.s,n=e.v,r=e.a,a=(200-t)*n/100;return{h:h(e.h),s:h(a>0&&a<200?t*n/100/(a<=100?a:200-a)*100:0),l:h(a/2),a:h(r,2)}},y=function(e){var t=v(e);return"hsl("+t.h+", "+t.s+"%, "+t.l+"%)"},b=function(e){var t=e.h,n=e.s,r=e.v,a=e.a;t=t/360*6,n/=100,r/=100;var o=Math.floor(t),s=r*(1-n),i=r*(1-(t-o)*n),c=r*(1-(1-t+o)*n),l=o%6;return{r:h(255*[r,i,s,s,c,r][l]),g:h(255*[c,r,r,i,s,s][l]),b:h(255*[s,s,c,r,r,i][l]),a:h(a,2)}},w=function(e){var t=e.toString(16);return t.length<2?"0"+t:t},S=function(e){var t=e.r,n=e.g,r=e.b,a=e.a,o=Math.max(t,n,r),s=o-Math.min(t,n,r),i=s?o===t?(n-r)/s:o===n?2+(r-t)/s:4+(t-n)/s:0;return{h:h(60*(i<0?i+6:i)),s:h(o?s/o*100:0),v:h(o/255*100),a:a}},E=r.memo((function(e){var t=e.hue,n=e.onChange,a=p(["react-colorful__hue",e.className]);return r.createElement("div",{className:a},r.createElement(d,{onMove:function(e){n({h:360*e.left})},onKey:function(e){n({h:i(t+360*e.left,0,360)})},"aria-label":"Hue","aria-valuetext":h(t)},r.createElement(m,{className:"react-colorful__hue-pointer",left:t/360,color:y({h:t,s:100,v:100,a:1})})))})),C=r.memo((function(e){var t=e.hsva,n=e.onChange,a={backgroundColor:y({h:t.h,s:100,v:100,a:1})};return r.createElement("div",{className:"react-colorful__saturation",style:a},r.createElement(d,{onMove:function(e){n({s:100*e.left,v:100-100*e.top})},onKey:function(e){n({s:i(t.s+100*e.left,0,100),v:i(t.v-100*e.top,0,100)})},"aria-label":"Color","aria-valuetext":"Saturation "+h(t.s)+"%, Brightness "+h(t.v)+"%"},r.createElement(m,{className:"react-colorful__saturation-pointer",top:1-t.v/100,left:t.s/100,color:y(t)})))})),F=function(e,t){if(e===t)return!0;for(var n in e)if(e[n]!==t[n])return!1;return!0};function T(e,t,n){var a=s(n),o=(0,r.useState)((function(){return e.toHsva(t)})),i=o[0],c=o[1],l=(0,r.useRef)({color:t,hsva:i});(0,r.useEffect)((function(){if(!e.equal(t,l.current.color)){var n=e.toHsva(t);l.current={hsva:n,color:t},c(n)}}),[t,e]),(0,r.useEffect)((function(){var t;F(i,l.current.hsva)||e.equal(t=e.fromHsva(i),l.current.color)||(l.current={hsva:i,color:t},a(t))}),[i,e,a]);var u=(0,r.useCallback)((function(e){c((function(t){return Object.assign({},t,e)}))}),[]);return[i,u]}var _,O="undefined"!=typeof window?r.useLayoutEffect:r.useEffect,I=new Map,N=function(e){O((function(){var t=e.current?e.current.ownerDocument:document;if(void 0!==t&&!I.has(t)){var r=t.createElement("style");r.innerHTML='.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>\')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}',I.set(t,r);var a=_||n.nc;a&&r.setAttribute("nonce",a),t.head.appendChild(r)}}),[])},R=function(e){var t=e.className,n=e.colorModel,s=e.color,i=void 0===s?n.defaultColor:s,c=e.onChange,l=o(e,["className","colorModel","color","onChange"]),u=(0,r.useRef)(null);N(u);var f=T(n,i,c),d=f[0],m=f[1],h=p(["react-colorful",t]);return r.createElement("div",a({},l,{ref:u,className:h}),r.createElement(C,{hsva:d,onChange:m}),r.createElement(E,{hue:d.h,onChange:m,className:"react-colorful__last-control"}))},A={defaultColor:"000",toHsva:function(e){return S(g(e))},fromHsva:function(e){return n=(t=b(e)).g,r=t.b,"#"+w(t.r)+w(n)+w(r);var t,n,r},equal:function(e,t){return e.toLowerCase()===t.toLowerCase()||F(g(e),g(t))}},k=function(e){return r.createElement(R,a({},e,{colorModel:A}))},P=/^#?([0-9A-F]{3,8})$/i,x=function(e){var t=e.color,n=void 0===t?"":t,i=e.onChange,c=e.onBlur,l=e.escape,u=e.validate,f=e.format,d=e.process,p=o(e,["color","onChange","onBlur","escape","validate","format","process"]),m=(0,r.useState)((function(){return l(n)})),h=m[0],g=m[1],v=s(i),y=s(c),b=(0,r.useCallback)((function(e){var t=l(e.target.value);g(t),u(t)&&v(d?d(t):t)}),[l,d,u,v]),w=(0,r.useCallback)((function(e){u(e.target.value)||g(l(n)),y(e)}),[n,l,u,y]);return(0,r.useEffect)((function(){g(l(n))}),[n,l]),r.createElement("input",a({},p,{value:f?f(h):h,spellCheck:"false",onChange:b,onBlur:w}))},D=function(e){return"#"+e},L=function(e){var t=e.prefixed,n=e.alpha,s=o(e,["prefixed","alpha"]),i=(0,r.useCallback)((function(e){return e.replace(/([^0-9A-F]+)/gi,"").substr(0,n?8:6)}),[n]),c=(0,r.useCallback)((function(e){return function(e,t){var n=P.exec(e),r=n?n[1].length:0;return 3===r||6===r||!!t&&4===r||!!t&&8===r}(e,n)}),[n]);return r.createElement(x,a({},s,{escape:i,format:t?D:void 0,process:D,validate:c}))}}}]);